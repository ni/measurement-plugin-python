# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ServiceLocation.proto, DiscoveryServices.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib


@dataclass
class ServiceLocation(betterproto.Message):
    """
    Represents the location of a service.  The location is generally the IP
    address and port number.  But it can also be something like a UDS socket.
    """

    # location (ipaddress) of the service
    location: str = betterproto.string_field(1)
    # optimal route (ipaddress) to use when communicating with the service This
    # may be a link-local connection, or a high speed link that is available
    # between the two communicating services
    optimal_route: str = betterproto.string_field(2)
    # port to use for insecure HTTP connections
    insecure_port: str = betterproto.string_field(3)
    # port to use for Secure SSL authenticated connections
    ssl_authenticated_port: str = betterproto.string_field(4)


@dataclass
class ServiceDescriptor(betterproto.Message):
    """
    Description of a registered service.  This information can be used to
    display to the user information about the service when services are being
    developed for a plug-in architecture
    """

    service_id: str = betterproto.string_field(1)
    # The user visible name of a service
    name: str = betterproto.string_field(2)
    # Url which provides descriptive information about the service
    description_url: str = betterproto.string_field(3)
    # The "class" of a service.  All services of the same class provide identical
    # functionality.  When a service interface is defined for a plug-in system
    # many services which provide different functionality may provide a service
    # by that interface. The class can be used to uniquely identify the
    # functionality the service provides.
    service_class: str = betterproto.string_field(4)


@dataclass
class RegisterServiceRequest(betterproto.Message):
    """Request used when registering a service"""

    # The service description
    service_description: "ServiceDescriptor" = betterproto.message_field(1)
    # The list of services the service instance provides.  These are the gRPC
    # Full Name of the service.  Registration can use the gRPC metadata to
    # provide this name
    provided_services: List[str] = betterproto.string_field(2)
    # The canonical location information for the service.
    location: "ServiceLocation" = betterproto.message_field(3)


@dataclass
class RegisterServiceResponse(betterproto.Message):
    """Response to registering a service"""

    # ID that can be used to unregister the service
    registration_id: str = betterproto.string_field(1)


@dataclass
class UnregisterServiceRequest(betterproto.Message):
    """Service unregistration request"""

    # The ID of the registered service to unregister
    registration_id: str = betterproto.string_field(1)


@dataclass
class UnregisterServiceResponse(betterproto.Message):
    """Response for registering a service"""

    pass


@dataclass
class EnumerateServicesRequest(betterproto.Message):
    """Requested used when enumerating a service"""

    # The gRPC full name of the service interface that is needed Caller can use
    # the gRPC metadata to provide this name
    required_service: str = betterproto.string_field(1)


@dataclass
class EnumerateServicesResponse(betterproto.Message):
    """Response used when enumerating services"""

    # The list of available services which implement the specified service
    # interface
    available_services: List["ServiceDescriptor"] = betterproto.message_field(1)


@dataclass
class ResolveServiceRequest(betterproto.Message):
    """Request used when resolving for a specific service instance"""

    # The location of the caller / consumer of the data provided by the service.
    request_data_location: str = betterproto.string_field(1)
    # The service "class" that is required
    required_service_class: str = betterproto.string_field(2)


@dataclass
class ResolveMonikerEndpointRequest(betterproto.Message):
    # The location, IP Address, which will be doing the communication with the
    # data endpoint
    request_location: str = betterproto.string_field(1)
    # The location of the source / sink of the data
    moniker_location: "ServiceLocation" = betterproto.message_field(2)


class RegistryServiceStub(betterproto.ServiceStub):
    """
    Service registry for the Measurement Services System. Measurement Services
    uses Client Used to:   Register Services - When a service starts up it can
    dynamically register   Service Enumeration - Find all classes of a service
    which implement a specific       service interface   Service Path
    Resolution - Used to find optimal instances and network paths to       a
    specific service
    """

    async def register_service(
        self,
        *,
        service_description: Optional["ServiceDescriptor"] = None,
        provided_services: List[str] = [],
        location: Optional["ServiceLocation"] = None,
    ) -> RegisterServiceResponse:
        """Registers a service instance with the registry"""

        request = RegisterServiceRequest()
        if service_description is not None:
            request.service_description = service_description
        request.provided_services = provided_services
        if location is not None:
            request.location = location

        return await self._unary_unary(
            "/ni.measurements.discovery.v1.RegistryService/RegisterService",
            request,
            RegisterServiceResponse,
        )

    async def unregister_service(
        self, *, registration_id: str = ""
    ) -> UnregisterServiceResponse:
        """Unregisters a service instance with the registry"""

        request = UnregisterServiceRequest()
        request.registration_id = registration_id

        return await self._unary_unary(
            "/ni.measurements.discovery.v1.RegistryService/UnregisterService",
            request,
            UnregisterServiceResponse,
        )

    async def enumerate_services(
        self, *, required_service: str = ""
    ) -> EnumerateServicesResponse:
        """
        Enumerate all services which implement a specific service interface
        This is useful for plugin type systems where the possible services are
        not know ahead of time.
        """

        request = EnumerateServicesRequest()
        request.required_service = required_service

        return await self._unary_unary(
            "/ni.measurements.discovery.v1.RegistryService/EnumerateServices",
            request,
            EnumerateServicesResponse,
        )

    async def resolve_service(
        self, *, request_data_location: str = "", required_service_class: str = ""
    ) -> ServiceLocation:
        """
        Given a specific service class this will find the best service
        implementation which best optimizes communication performance. Factors
        such as data path and service load will be taken into account
        """

        request = ResolveServiceRequest()
        request.request_data_location = request_data_location
        request.required_service_class = required_service_class

        return await self._unary_unary(
            "/ni.measurements.discovery.v1.RegistryService/ResolveService",
            request,
            ServiceLocation,
        )

    async def resolve_moniker_endpoint(
        self,
        *,
        request_location: str = "",
        moniker_location: Optional["ServiceLocation"] = None,
    ) -> ServiceLocation:
        """
        Given a specific moniker endpoint this will find the best data path to
        use to optimize the performance of communcation.  For example if there
        are multiple network paths (1Gb public IP, and 10Gb link-local) this
        will resolve to the path which will give the best performance.
        """

        request = ResolveMonikerEndpointRequest()
        request.request_location = request_location
        if moniker_location is not None:
            request.moniker_location = moniker_location

        return await self._unary_unary(
            "/ni.measurements.discovery.v1.RegistryService/ResolveMonikerEndpoint",
            request,
            ServiceLocation,
        )
