"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
---------------------------------------------------------------------
---------------------------------------------------------------------
"""
import abc
import collections.abc
import grpc
import grpc.aio
import ni_measurementlink_service._internal.stubs.ni.measurementlink.discovery.v1.discovery_service_pb2 as ni_measurementlink_discovery_v1_discovery_service_pb2
import typing

_T = typing.TypeVar('_T')

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta):
    ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore
    ...

class DiscoveryServiceStub:
    """The service used as a registry for other services. This service can be used to discover
    and activate other services present in the system.
    """

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    RegisterService: grpc.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceResponse,
    ]
    """Registers a service instance with the discovery service.
    Status Codes for errors:
    - INVALID_ARGUMENT:
      - ServiceDescriptor.display_name is empty
      - ServiceDescriptor.provided_interfaces is empty
      - ServiceDescriptor.service_class is empty
      - ServiceLocation.location is empty
      - Both ServiceLocation.insecure_port and ServiceLocation.ssl_authenticated_port are empty
      - Either ServiceLocation.insecure_port or ServiceLocation.ssl_authenticated_port contain an invalid port number
    """
    UnregisterService: grpc.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceResponse,
    ]
    """Unregisters a service instance with the discovery service."""
    EnumerateServices: grpc.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesResponse,
    ]
    """Enumerate all services which implement a specific service interface.
    This is useful for plugin type systems where the possible services are not known ahead of time.
    """
    ResolveService: grpc.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.ResolveServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.ServiceLocation,
    ]
    """Given a description of a service, returns information that can be used to establish communication
    with that service. If necessary, the service will be started by the discovery service if it has not
    already been started. Activation of the service is accomplished through use of a .serviceconfig file
    which includes information describing the service. Services that register a .serviceconfig file must
    call RegisterService when their service is started or this call will never complete successfully when
    the discovery service attempts to start it.
    Status Codes for errors:
    - INVALID_ARGUMENT: provided_interfaces is empty
    - NOT_FOUND: No service matching the resolve request was found
    - FAILED_PRECONDITION: More than one service matching the resolve request was found
    """

class DiscoveryServiceAsyncStub:
    """The service used as a registry for other services. This service can be used to discover
    and activate other services present in the system.
    """

    RegisterService: grpc.aio.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceResponse,
    ]
    """Registers a service instance with the discovery service.
    Status Codes for errors:
    - INVALID_ARGUMENT:
      - ServiceDescriptor.display_name is empty
      - ServiceDescriptor.provided_interfaces is empty
      - ServiceDescriptor.service_class is empty
      - ServiceLocation.location is empty
      - Both ServiceLocation.insecure_port and ServiceLocation.ssl_authenticated_port are empty
      - Either ServiceLocation.insecure_port or ServiceLocation.ssl_authenticated_port contain an invalid port number
    """
    UnregisterService: grpc.aio.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceResponse,
    ]
    """Unregisters a service instance with the discovery service."""
    EnumerateServices: grpc.aio.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesResponse,
    ]
    """Enumerate all services which implement a specific service interface.
    This is useful for plugin type systems where the possible services are not known ahead of time.
    """
    ResolveService: grpc.aio.UnaryUnaryMultiCallable[
        ni_measurementlink_discovery_v1_discovery_service_pb2.ResolveServiceRequest,
        ni_measurementlink_discovery_v1_discovery_service_pb2.ServiceLocation,
    ]
    """Given a description of a service, returns information that can be used to establish communication
    with that service. If necessary, the service will be started by the discovery service if it has not
    already been started. Activation of the service is accomplished through use of a .serviceconfig file
    which includes information describing the service. Services that register a .serviceconfig file must
    call RegisterService when their service is started or this call will never complete successfully when
    the discovery service attempts to start it.
    Status Codes for errors:
    - INVALID_ARGUMENT: provided_interfaces is empty
    - NOT_FOUND: No service matching the resolve request was found
    - FAILED_PRECONDITION: More than one service matching the resolve request was found
    """

class DiscoveryServiceServicer(metaclass=abc.ABCMeta):
    """The service used as a registry for other services. This service can be used to discover
    and activate other services present in the system.
    """

    @abc.abstractmethod
    def RegisterService(
        self,
        request: ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceRequest,
        context: _ServicerContext,
    ) -> typing.Union[ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceResponse, collections.abc.Awaitable[ni_measurementlink_discovery_v1_discovery_service_pb2.RegisterServiceResponse]]:
        """Registers a service instance with the discovery service.
        Status Codes for errors:
        - INVALID_ARGUMENT:
          - ServiceDescriptor.display_name is empty
          - ServiceDescriptor.provided_interfaces is empty
          - ServiceDescriptor.service_class is empty
          - ServiceLocation.location is empty
          - Both ServiceLocation.insecure_port and ServiceLocation.ssl_authenticated_port are empty
          - Either ServiceLocation.insecure_port or ServiceLocation.ssl_authenticated_port contain an invalid port number
        """
    @abc.abstractmethod
    def UnregisterService(
        self,
        request: ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceRequest,
        context: _ServicerContext,
    ) -> typing.Union[ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceResponse, collections.abc.Awaitable[ni_measurementlink_discovery_v1_discovery_service_pb2.UnregisterServiceResponse]]:
        """Unregisters a service instance with the discovery service."""
    @abc.abstractmethod
    def EnumerateServices(
        self,
        request: ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesRequest,
        context: _ServicerContext,
    ) -> typing.Union[ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesResponse, collections.abc.Awaitable[ni_measurementlink_discovery_v1_discovery_service_pb2.EnumerateServicesResponse]]:
        """Enumerate all services which implement a specific service interface.
        This is useful for plugin type systems where the possible services are not known ahead of time.
        """
    @abc.abstractmethod
    def ResolveService(
        self,
        request: ni_measurementlink_discovery_v1_discovery_service_pb2.ResolveServiceRequest,
        context: _ServicerContext,
    ) -> typing.Union[ni_measurementlink_discovery_v1_discovery_service_pb2.ServiceLocation, collections.abc.Awaitable[ni_measurementlink_discovery_v1_discovery_service_pb2.ServiceLocation]]:
        """Given a description of a service, returns information that can be used to establish communication
        with that service. If necessary, the service will be started by the discovery service if it has not
        already been started. Activation of the service is accomplished through use of a .serviceconfig file
        which includes information describing the service. Services that register a .serviceconfig file must
        call RegisterService when their service is started or this call will never complete successfully when
        the discovery service attempts to start it.
        Status Codes for errors:
        - INVALID_ARGUMENT: provided_interfaces is empty
        - NOT_FOUND: No service matching the resolve request was found
        - FAILED_PRECONDITION: More than one service matching the resolve request was found
        """

def add_DiscoveryServiceServicer_to_server(servicer: DiscoveryServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
